Tasks and Qualifications: 
The Real-Time Software Engineer is responsible for developing and implementing 
software applications in a real-time environment using the C language. This role 
requires a deep understanding of text and source code pre-processing, as well as
experience building components and plugins. The candidate should have expertise 
in software engineering principles and real-time systems, with the ability to work 
collaboratively and independently to meet project objectives. 

Main Job Objectives  
Assist in the design and development of real-time software applications. Write code 
for simple software components and plugins. Participate in code reviews and provide 
feedback to other team members. Debug and test software applications to ensure that 
they meet requirements and are free from defects. Design and develop software applications 
for real-time environments, ensuring that they are scalable, maintainable, and reliable. 
Analyse user requirements and design software solutions to meet these requirements. 
Write high-quality code that is easy to maintain and extend. Collaborate with cross-functional 
eams to develop and integrate software components into larger systems. Work with software engineers, 
system architects, and project managers to ensure that software is delivered on time, within budget, 
and to specifications. Participate in peer review such as code design, test reviews and provide constructive 
feedback to other team members. Maintain and improve existing software applications, including 
troubleshooting and bug fixes. Stay up to date with new technologies, software development tools,
and best practices to ensure that software applications remain cutting-edge and competitive.  

1. Text and source code pre procesing + how to read and write file 
2. Components and plugins 
3. Software enineering principle 
  1. DRY - Don't Repeat Yourself (reuse code)                                          
  2. KISS - Keep It Simple                                                             
  3. Modularity - break code into small, focused functions                             
  4. Readability - clear naming, comments where needed                                 
  5. Error handling - check return values, handle edge cases                           
  6. Testing - verify code works before shipping                                       
  7. Version control - use git, commit often                                           
  8. Code review - have others check your work  

SDLC 
● Software Development Life Cycle - phases of building software:                       
                                                                                       
  1. Requirements - what does the client/user need?                                    
  2. Design - how will we build it? (architecture, data structures)                    
  3. Implementation - write the code                                                   
  4. Testing - verify it works                                                         
  5. Deployment - release to users                                                     
  6. Maintenance - bug fixes, updates                                                  
                                                                                       
  Common models:                                                                       
  - Waterfall - linear, one phase after another                                        
  - Agile - iterative, short sprints, frequent delivery                                
  - V-Model - testing at each phase   

4. Real time system 
5. Components 
6. Plugins 
7. Real time software 
8. Code review and feedback
9. Debug 
10.Test 
11. Edge cases  ( finish until edge cases tomorrow, say out loud to practice)
12. scalable, maintainable, reliable
13. Analyse user requirements
14. Desing software 
15. Collaboration 
16. Integrate software componenets into larger system 
17. delivered on time, in budget, and specifications
18. Peer review, constructive feedback 
19. Maintain and improve existing software
20. troubleshooting and bug fixes 
21. How do you stay up to date to make sure software cutting edge and competitive


** Tell me about yourself 
  "I'm a first-year Computer Science student at Salford, currently achieving first     
  class at 80%. I've been building full-stack applications—my main project is a Spring 
  Boot API where I implemented modular components, automated testing with JUnit, and   
  CI/CD pipelines on Google Cloud.                                                     
                                                                                       
  What draws me to this role is the focus on software engineering principles—I've      
  applied these in practice as a Scrum master, leading a team of seven using Agile     
  methodology and proper SDLC processes. I've also implemented code review workflows   
  and Git branching strategies for team collaboration.                                 
                                                                                       
  I'm particularly interested in real-time systems and working closer to the hardware  
  level with C. I understand the importance of writing reliable, maintainable code     
  where performance and timing matter—especially in systems where you can't afford     
  unpredictable behavior like dynamic memory allocation.                               
                                                                                       
  I'm looking to grow my skills in low-level programming and contribute to building    
  scalable software components that integrate into larger systems."   

    "I'll be honest—my C experience is limited compared to my work in Java and Python.   
  But I've been actively learning it, and I find the lower-level concepts like memory  
  management and pointers genuinely interesting. I pick things up quickly, and I'm     
  confident I can get up to speed with the right guidance." 